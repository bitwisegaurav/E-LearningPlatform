<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../common_files/inner.css">
    <title>Finite State Machines and Languages</title>
</head>
<body>
    <h1>Automata</h1>
    <h2>What is Automata?</h2>
    <p>Study of mathematical machines or systems are called as <span>Automata</span>.</p>

    <ul>
        <li><span>Symbols : </span>Symbols are the basic building block, which can be character/token. For e.g. a,b,1,2.</li>
        <li>
            <strong>Alphabets : </strong> Sets of symbols used to form strings. It is denoted as "Σ". For e.g. A = {a,b,1,2}.
        </li>
        <li>
            <strong>Strings : </strong> Sequences of symbols from an alphabet. For example aa, aaaa, ababaa, a1a1a1ab, etc.
        </li>
        <li>
            <strong>Language : </strong> A set of strings over a specific alphabet. For example L = {aa, aba, abb, a1a1a1a, ...}.
        </li>
    </ul>

    <h2>Langugaes</h2>
    <p>We need a language for communication with machines.</p>
    <p>Languages can be of two types : </p>
    <ul>
        <li>Formal Language</li>
        <li>Informal Language</li>
    </ul>
    <p class="note note-normal">Grammars are language generators and machines are languages acceptors.</p>

    <h2>Formal Languages</h2>

    <p>Formal languages, described by grammars, can be recognized and generated by Finite State Machines. Key components include : </p>

    <h3>Regular Languages</h3>

    <p>Regular Languages are those that can be recognized by Finite State Machines. They are associated with Regular Expressions, providing a concise way to describe patterns in strings.</p>

    <h2>Basic Terminologies</h2>
    <ul>
        <li><span>Length of string : </span>Number of symbol in the string. Represented in mod or | |. For e.g. A = abababa, |A| = 7.</li>
        <!-- concatenation -->
        <li><span>Concatenation : </span>Concatenation of two strings is the result of joining the two strings end-to-end. For example A = abc, B = def then AB = abcdef.
            <p>A.A.A or AAA = A<sup>3</sup> <span>or</span> AA.. n times = A<sup>n</sup>.</p>
        </li>
        <!-- reverse of string -->
        <li><span>Reverse of string : </span>Reverse of a string is the string obtained by reversing the order of the symbols in the string. For example A = abc, then A' or A<sup>r</sup> = cba.
            <p>A ≠ A<sup>r</sup> and |A| = |A<sup>r</sup>|.</p>
        </li>
        <li><span>Empty/Null String : </span>A sting with no or zero occurence of symbol. It is represented as "&epsilon;" or "&lambda;".</li>
        <!-- substring -->
        <li><span>Substring : </span>Any string of <span>consecutive</span> symbols which are in <span>same order</span> as in original/complete string. For example A = something, then A = some.
            <p class="note note-normal">&epsilon; is a substring, prefix and suffix of every string. <br> No. of substrings for a string whose all symbols are distinct and unique = [n(n+1)/2] + 1.</p>
        </li>
        <!-- trivial substring -->
        <li><span>Trivial substring : </span> &epsilon; and original string as sustring.</li>
        <!-- prefix -->
        <li><span>Prefix : </span>Any string of length n with <span>consecutive</span> symbols which are in <span>same order
            </span> as in original/complete string which must start from the point of original string. For example A = something, then prefix = so.
        </li>
        <!-- suffix -->
        <li><span>Suffix : </span>Any string of length n with <span>consecutive</span> symbols which are in <span>same order</span> as in original/complete string which must end at the point of original string. For example A = something, then suffix = ng.
            <p>Number of prefixes/suffix = |A| + 1.</p>
        </li>
        <!-- kleene closure -->
        <li><span>Kleene Closure : </span> A set of strings obtained by concatenating symbols of length from 0 to &infin; from alphabets. Denoted as Σ<sup>*</sup>.
            <div class="code">
                <pre>Σ<sup>*</sup> = U<sup>&infin;</sup><sub>i=0</sub> {x : |x| = i}</pre>
            </div>
        </li>
        <li><span>Positive Closure : </span>Kleene Closure except the values of string of length 0 or &epsilon;. Denoted as Σ<sup>+</sup>.
            <div class="code">
                <pre>Σ<sup>+</sup> = U<sup>&infin;</sup><sub>i=1</sub> {x : |x| = i}</pre>
            </div>
        </li>
    </ul>

    <h2>Finite Automata/State Machine</h2>
    <p>It is a model that has a finite set of states and its control moves from one state to another in response to external inputs.</p>
    <p>It can be broadly classified in two types : </p>
    <ul>
        <li><span>FSM without output : </span>
            <ol>
                <li><span>Deterministic Finite Automata (DFA) : </span>For every current state and input, there is exactly one next state.</li>
                <li><span>Non Deterministic Finite Automata (NFA) : </span>For a given current state and input, there can be multiple possible next states.</li>
            </ol>
        </li>
        <li><span>FSM with output : </span>
            <ol>
                <li>Moore machine</li>
                <li>Mealy machine</li>
            </ol>
        </li>
    </ul>

    <h2>Tuples in DFA</h2>

    <p>DFA is defined by 5 tuples : </p>

    <ul>
        <li>
            <strong>States : </strong> It is the finite and non empty set of states and it is denoted by Q.
        </li>
        <li>
            <span>Inputs : </span> Σ is the set of input symbols.
        </li>
        <li>
            <strong>Transitions : </strong> Define how the system moves from one state to another based on input. And it is denoted as &delta;.
            <div class="code">
                <pre>&delta; : Q &cross; Σ &RightArrow; Q</pre>
            </div>
        </li>
        <li>
            <strong>Start State : </strong> The initial state of the system. And it is denoted as S/q<sub>0</sub>.
        </li>
        <li>
            <strong>Final States : </strong> It is a set of states which indicates a successful completion of a sequence of inputs. And can be represented as F.
        </li>
    </ul>

    <h2>Acceptance By DFA</h2>
    <p>If there exist a transition for which it starts at the initial state and ends in any one of the final states, then the string is said to be accepted by DFA.</p>
    <div class="code">
        <pre>L(M) = { x ∈ Σ<sup>*</sup> : &delta;<sup>*</sup>(S,x) ∈ F } </pre>
    </div>

    <h2>Representation</h2>

    <h4>Transition State Diagram</h4>
    <p>It is a graphical representation of the transition function.</p>
    <!-- write in imp note that it is necessary to also make states for the values that are not going to be accepted -->
    <p class="note note-imp">It is necessary to also include states for the values that are not going to be accepted.</p>

    <h4>Transition Table</h4>
    <p>It is a table representation of the transition function.</p>

    <h4>Transition Id</h4>
    <p>It is a number that represents the transition function.</p>
    <div class="code">
        <pre>
Q = {q<sub>0</sub>, q<sub>1</sub>, q<sub>2</sub>, q<sub>3</sub>, q<sub>4</sub>}
Σ = {0, 1}
S = q<sub>0</sub>
F = {q<sub>2</sub>, q<sub>4</sub>}
&delta; = {
    (q<sub>0</sub>, 0) = q<sub>1</sub>, (q<sub>0</sub>, 1) = q<sub>3</sub>, (q<sub>1</sub>, 0) = q<sub>1</sub>, (q<sub>1</sub>, 1) = q<sub>2</sub>,
    (q<sub>2</sub>, 0) = q<sub>2</sub>, (q<sub>2</sub>, 1) = q<sub>2</sub>, (q<sub>3</sub>, 0) = q<sub>4</sub>, (q<sub>3</sub>, 1) = q<sub>2</sub>,
    (q<sub>4</sub>, 0) = q<sub>4</sub>, (q<sub>4</sub>, 1) = q<sub>4</sub>
}</pre>
    </div>
 
    <h2>Application in Computer Science</h2>

    <p>Finite State Machines are widely used in various computer science applications, including : </p>

    <ul>
        <li>Lexical analysis in compilers.</li>
        <li>Pattern recognition.</li>
        <li>Network protocols.</li>
        <li>Modeling behavior in software systems.</li>
    </ul>

</body>
<script src="../common_files/innerTheme.js"></script>
</html>